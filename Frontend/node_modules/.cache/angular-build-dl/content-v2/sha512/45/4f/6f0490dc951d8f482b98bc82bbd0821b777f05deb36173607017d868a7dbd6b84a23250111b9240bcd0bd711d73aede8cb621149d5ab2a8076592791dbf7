{"version":3,"sources":["./node_modules/ngx-echarts/__ivy_ngcc__/fesm2015/ngx-echarts.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAuD;AACsE;AACvE;AACT;AACF;;AAEH;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wCAAE;AACzB;AACA;AACA,eAAe,uCAAK;AACpB;AACA;AACA;AACA;AACA,mBAAmB,wCAAE;AACrB;AACA,eAAe,uCAAK;AACpB;AACA;AACA;AACA;AACA,mBAAmB,wCAAE;AACrB;AACA,eAAe,uCAAK;AACpB;AACA;AACA;AACA;AACA;AACA,uBAAuB,wCAAE;AACzB;AACA;AACA,eAAe,uCAAK;AACpB;AACA;;AAEA,+BAA+B,yDAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAY;AACzC,gCAAgC,uDAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6DAAc;AAC/C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gDAAS;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC,SAAS;AACT;AACA;AACA,eAAe,gDAAS;AACxB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,gDAAS;AACxB;AACA;AAC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","file":"default-node_modules_ngx-echarts___ivy_ngcc___fesm2015_ngx-echarts_js-es2015.js","sourcesContent":["import { __awaiter, __decorate, __param } from 'tslib';\nimport { InjectionToken, EventEmitter, Inject, ElementRef, NgZone, Input, Output, Directive, NgModule } from '@angular/core';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport { of, EMPTY, Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\nimport * as ɵngcc0 from '@angular/core';\nclass ChangeFilter {\n    constructor(changes) {\n        this.changes = changes;\n    }\n    static of(changes) {\n        return new ChangeFilter(changes);\n    }\n    notEmpty(key) {\n        if (this.changes[key]) {\n            const value = this.changes[key].currentValue;\n            if (value !== undefined && value !== null) {\n                return of(value);\n            }\n        }\n        return EMPTY;\n    }\n    has(key) {\n        if (this.changes[key]) {\n            const value = this.changes[key].currentValue;\n            return of(value);\n        }\n        return EMPTY;\n    }\n    notFirst(key) {\n        if (this.changes[key] && !this.changes[key].isFirstChange()) {\n            const value = this.changes[key].currentValue;\n            return of(value);\n        }\n        return EMPTY;\n    }\n    notFirstAndEmpty(key) {\n        if (this.changes[key] && !this.changes[key].isFirstChange()) {\n            const value = this.changes[key].currentValue;\n            if (value !== undefined && value !== null) {\n                return of(value);\n            }\n        }\n        return EMPTY;\n    }\n}\n\nconst NGX_ECHARTS_CONFIG = new InjectionToken('NGX_ECHARTS_CONFIG');\nlet NgxEchartsDirective = class NgxEchartsDirective {\n    constructor(config, el, ngZone) {\n        this.el = el;\n        this.ngZone = ngZone;\n        this.autoResize = true;\n        this.loadingType = 'default';\n        // ngx-echarts events\n        this.chartInit = new EventEmitter();\n        this.optionsError = new EventEmitter();\n        // echarts mouse events\n        this.chartClick = this.createLazyEvent('click');\n        this.chartDblClick = this.createLazyEvent('dblclick');\n        this.chartMouseDown = this.createLazyEvent('mousedown');\n        this.chartMouseMove = this.createLazyEvent('mousemove');\n        this.chartMouseUp = this.createLazyEvent('mouseup');\n        this.chartMouseOver = this.createLazyEvent('mouseover');\n        this.chartMouseOut = this.createLazyEvent('mouseout');\n        this.chartGlobalOut = this.createLazyEvent('globalout');\n        this.chartContextMenu = this.createLazyEvent('contextmenu');\n        // echarts mouse events\n        this.chartLegendSelectChanged = this.createLazyEvent('legendselectchanged');\n        this.chartLegendSelected = this.createLazyEvent('legendselected');\n        this.chartLegendUnselected = this.createLazyEvent('legendunselected');\n        this.chartLegendScroll = this.createLazyEvent('legendscroll');\n        this.chartDataZoom = this.createLazyEvent('datazoom');\n        this.chartDataRangeSelected = this.createLazyEvent('datarangeselected');\n        this.chartTimelineChanged = this.createLazyEvent('timelinechanged');\n        this.chartTimelinePlayChanged = this.createLazyEvent('timelineplaychanged');\n        this.chartRestore = this.createLazyEvent('restore');\n        this.chartDataViewChanged = this.createLazyEvent('dataviewchanged');\n        this.chartMagicTypeChanged = this.createLazyEvent('magictypechanged');\n        this.chartPieSelectChanged = this.createLazyEvent('pieselectchanged');\n        this.chartPieSelected = this.createLazyEvent('pieselected');\n        this.chartPieUnselected = this.createLazyEvent('pieunselected');\n        this.chartMapSelectChanged = this.createLazyEvent('mapselectchanged');\n        this.chartMapSelected = this.createLazyEvent('mapselected');\n        this.chartMapUnselected = this.createLazyEvent('mapunselected');\n        this.chartAxisAreaSelected = this.createLazyEvent('axisareaselected');\n        this.chartFocusNodeAdjacency = this.createLazyEvent('focusnodeadjacency');\n        this.chartUnfocusNodeAdjacency = this.createLazyEvent('unfocusnodeadjacency');\n        this.chartBrush = this.createLazyEvent('brush');\n        this.chartBrushEnd = this.createLazyEvent('brushend');\n        this.chartBrushSelected = this.createLazyEvent('brushselected');\n        this.chartRendered = this.createLazyEvent('rendered');\n        this.chartFinished = this.createLazyEvent('finished');\n        this.animationFrameID = null;\n        this.echarts = config.echarts;\n    }\n    ngOnChanges(changes) {\n        const filter = ChangeFilter.of(changes);\n        filter.notFirstAndEmpty('options').subscribe((opt) => this.onOptionsChange(opt));\n        filter.notFirstAndEmpty('merge').subscribe((opt) => this.setOption(opt));\n        filter.has('loading').subscribe((v) => this.toggleLoading(!!v));\n        filter.notFirst('theme').subscribe(() => this.refreshChart());\n    }\n    ngOnInit() {\n        if (this.autoResize) {\n            this.resizeSub = new ResizeObserver(() => {\n                this.animationFrameID = window.requestAnimationFrame(() => this.resize());\n            });\n            this.resizeSub.observe(this.el.nativeElement);\n        }\n    }\n    ngOnDestroy() {\n        if (this.resizeSub) {\n            this.resizeSub.unobserve(this.el.nativeElement);\n            window.cancelAnimationFrame(this.animationFrameID);\n        }\n        this.dispose();\n    }\n    ngAfterViewInit() {\n        setTimeout(() => this.initChart());\n    }\n    dispose() {\n        if (this.chart) {\n            this.chart.dispose();\n            this.chart = null;\n        }\n    }\n    /**\n     * resize chart\n     */\n    resize() {\n        if (this.chart) {\n            this.chart.resize();\n        }\n    }\n    toggleLoading(loading) {\n        if (this.chart) {\n            loading\n                ? this.chart.showLoading(this.loadingType, this.loadingOpts)\n                : this.chart.hideLoading();\n        }\n    }\n    setOption(option, opts) {\n        if (this.chart) {\n            try {\n                this.chart.setOption(option, opts);\n            }\n            catch (e) {\n                console.error(e);\n                this.optionsError.emit(e);\n            }\n        }\n    }\n    /**\n     * dispose old chart and create a new one.\n     */\n    refreshChart() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.dispose();\n            yield this.initChart();\n        });\n    }\n    createChart() {\n        const dom = this.el.nativeElement;\n        if (window && window.getComputedStyle) {\n            const prop = window.getComputedStyle(dom, null).getPropertyValue('height');\n            if ((!prop || prop === '0px') && (!dom.style.height || dom.style.height === '0px')) {\n                dom.style.height = '400px';\n            }\n        }\n        // here a bit tricky: we check if the echarts module is provided as function returning native import('...') then use the promise\n        // otherwise create the function that imitates behaviour above with a provided as is module\n        return this.ngZone.runOutsideAngular(() => {\n            const load = typeof this.echarts === 'function' ? this.echarts : () => Promise.resolve(this.echarts);\n            return load().then(({ init }) => init(dom, this.theme, this.initOpts));\n        });\n    }\n    initChart() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.onOptionsChange(this.options);\n            if (this.merge && this.chart) {\n                this.setOption(this.merge);\n            }\n        });\n    }\n    onOptionsChange(opt) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!opt) {\n                return;\n            }\n            if (this.chart) {\n                this.setOption(this.options, true);\n            }\n            else {\n                this.chart = yield this.createChart();\n                this.chartInit.emit(this.chart);\n                this.setOption(this.options, true);\n            }\n        });\n    }\n    // allows to lazily bind to only those events that are requested through the `@Output` by parent components\n    // see https://stackoverflow.com/questions/51787972/optimal-reentering-the-ngzone-from-eventemitter-event for more info\n    createLazyEvent(eventName) {\n        return this.chartInit.pipe(switchMap((chart) => new Observable((observer) => {\n            chart.on(eventName, (data) => this.ngZone.run(() => observer.next(data)));\n            return () => chart.off(eventName);\n        })));\n    }\n};\nNgxEchartsDirective.ɵfac = function NgxEchartsDirective_Factory(t) { return new (t || NgxEchartsDirective)(ɵngcc0.ɵɵdirectiveInject(NGX_ECHARTS_CONFIG), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };\nNgxEchartsDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NgxEchartsDirective, selectors: [[\"echarts\"], [\"\", \"echarts\", \"\"]], inputs: { autoResize: \"autoResize\", loadingType: \"loadingType\", options: \"options\", theme: \"theme\", loading: \"loading\", initOpts: \"initOpts\", merge: \"merge\", loadingOpts: \"loadingOpts\" }, outputs: { chartInit: \"chartInit\", optionsError: \"optionsError\", chartClick: \"chartClick\", chartDblClick: \"chartDblClick\", chartMouseDown: \"chartMouseDown\", chartMouseMove: \"chartMouseMove\", chartMouseUp: \"chartMouseUp\", chartMouseOver: \"chartMouseOver\", chartMouseOut: \"chartMouseOut\", chartGlobalOut: \"chartGlobalOut\", chartContextMenu: \"chartContextMenu\", chartLegendSelectChanged: \"chartLegendSelectChanged\", chartLegendSelected: \"chartLegendSelected\", chartLegendUnselected: \"chartLegendUnselected\", chartLegendScroll: \"chartLegendScroll\", chartDataZoom: \"chartDataZoom\", chartDataRangeSelected: \"chartDataRangeSelected\", chartTimelineChanged: \"chartTimelineChanged\", chartTimelinePlayChanged: \"chartTimelinePlayChanged\", chartRestore: \"chartRestore\", chartDataViewChanged: \"chartDataViewChanged\", chartMagicTypeChanged: \"chartMagicTypeChanged\", chartPieSelectChanged: \"chartPieSelectChanged\", chartPieSelected: \"chartPieSelected\", chartPieUnselected: \"chartPieUnselected\", chartMapSelectChanged: \"chartMapSelectChanged\", chartMapSelected: \"chartMapSelected\", chartMapUnselected: \"chartMapUnselected\", chartAxisAreaSelected: \"chartAxisAreaSelected\", chartFocusNodeAdjacency: \"chartFocusNodeAdjacency\", chartUnfocusNodeAdjacency: \"chartUnfocusNodeAdjacency\", chartBrush: \"chartBrush\", chartBrushEnd: \"chartBrushEnd\", chartBrushSelected: \"chartBrushSelected\", chartRendered: \"chartRendered\", chartFinished: \"chartFinished\" }, exportAs: [\"echarts\"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });\nNgxEchartsDirective.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [NGX_ECHARTS_CONFIG,] }] },\n    { type: ElementRef },\n    { type: NgZone }\n];\n__decorate([\n    Input()\n], NgxEchartsDirective.prototype, \"options\", void 0);\n__decorate([\n    Input()\n], NgxEchartsDirective.prototype, \"theme\", void 0);\n__decorate([\n    Input()\n], NgxEchartsDirective.prototype, \"loading\", void 0);\n__decorate([\n    Input()\n], NgxEchartsDirective.prototype, \"initOpts\", void 0);\n__decorate([\n    Input()\n], NgxEchartsDirective.prototype, \"merge\", void 0);\n__decorate([\n    Input()\n], NgxEchartsDirective.prototype, \"autoResize\", void 0);\n__decorate([\n    Input()\n], NgxEchartsDirective.prototype, \"loadingType\", void 0);\n__decorate([\n    Input()\n], NgxEchartsDirective.prototype, \"loadingOpts\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartInit\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"optionsError\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartClick\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartDblClick\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartMouseDown\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartMouseMove\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartMouseUp\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartMouseOver\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartMouseOut\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartGlobalOut\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartContextMenu\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartLegendSelectChanged\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartLegendSelected\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartLegendUnselected\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartLegendScroll\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartDataZoom\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartDataRangeSelected\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartTimelineChanged\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartTimelinePlayChanged\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartRestore\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartDataViewChanged\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartMagicTypeChanged\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartPieSelectChanged\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartPieSelected\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartPieUnselected\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartMapSelectChanged\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartMapSelected\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartMapUnselected\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartAxisAreaSelected\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartFocusNodeAdjacency\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartUnfocusNodeAdjacency\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartBrush\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartBrushEnd\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartBrushSelected\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartRendered\", void 0);\n__decorate([\n    Output()\n], NgxEchartsDirective.prototype, \"chartFinished\", void 0);\nNgxEchartsDirective = __decorate([ __param(0, Inject(NGX_ECHARTS_CONFIG))\n], NgxEchartsDirective);\n\nvar NgxEchartsModule_1;\nlet NgxEchartsModule = NgxEchartsModule_1 = class NgxEchartsModule {\n    static forRoot(config) {\n        return {\n            ngModule: NgxEchartsModule_1,\n            providers: [{ provide: NGX_ECHARTS_CONFIG, useValue: config }],\n        };\n    }\n    static forChild() {\n        return {\n            ngModule: NgxEchartsModule_1,\n        };\n    }\n};\nNgxEchartsModule.ɵfac = function NgxEchartsModule_Factory(t) { return new (t || NgxEchartsModule)(); };\nNgxEchartsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgxEchartsModule });\nNgxEchartsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[]] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxEchartsDirective, [{\n        type: Directive,\n        args: [{\n                selector: 'echarts, [echarts]',\n                exportAs: 'echarts'\n            }]\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [NGX_ECHARTS_CONFIG]\n            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { autoResize: [{\n            type: Input\n        }], loadingType: [{\n            type: Input\n        }], chartInit: [{\n            type: Output\n        }], optionsError: [{\n            type: Output\n        }], chartClick: [{\n            type: Output\n        }], chartDblClick: [{\n            type: Output\n        }], chartMouseDown: [{\n            type: Output\n        }], chartMouseMove: [{\n            type: Output\n        }], chartMouseUp: [{\n            type: Output\n        }], chartMouseOver: [{\n            type: Output\n        }], chartMouseOut: [{\n            type: Output\n        }], chartGlobalOut: [{\n            type: Output\n        }], chartContextMenu: [{\n            type: Output\n        }], chartLegendSelectChanged: [{\n            type: Output\n        }], chartLegendSelected: [{\n            type: Output\n        }], chartLegendUnselected: [{\n            type: Output\n        }], chartLegendScroll: [{\n            type: Output\n        }], chartDataZoom: [{\n            type: Output\n        }], chartDataRangeSelected: [{\n            type: Output\n        }], chartTimelineChanged: [{\n            type: Output\n        }], chartTimelinePlayChanged: [{\n            type: Output\n        }], chartRestore: [{\n            type: Output\n        }], chartDataViewChanged: [{\n            type: Output\n        }], chartMagicTypeChanged: [{\n            type: Output\n        }], chartPieSelectChanged: [{\n            type: Output\n        }], chartPieSelected: [{\n            type: Output\n        }], chartPieUnselected: [{\n            type: Output\n        }], chartMapSelectChanged: [{\n            type: Output\n        }], chartMapSelected: [{\n            type: Output\n        }], chartMapUnselected: [{\n            type: Output\n        }], chartAxisAreaSelected: [{\n            type: Output\n        }], chartFocusNodeAdjacency: [{\n            type: Output\n        }], chartUnfocusNodeAdjacency: [{\n            type: Output\n        }], chartBrush: [{\n            type: Output\n        }], chartBrushEnd: [{\n            type: Output\n        }], chartBrushSelected: [{\n            type: Output\n        }], chartRendered: [{\n            type: Output\n        }], chartFinished: [{\n            type: Output\n        }], options: [{\n            type: Input\n        }], theme: [{\n            type: Input\n        }], loading: [{\n            type: Input\n        }], initOpts: [{\n            type: Input\n        }], merge: [{\n            type: Input\n        }], loadingOpts: [{\n            type: Input\n        }] }); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxEchartsModule, [{\n        type: NgModule,\n        args: [{\n                imports: [],\n                declarations: [NgxEchartsDirective],\n                exports: [NgxEchartsDirective]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxEchartsModule, { declarations: [NgxEchartsDirective], exports: [NgxEchartsDirective] }); })();\n\n/*\n * Public API Surface of ngx-echarts\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NGX_ECHARTS_CONFIG, NgxEchartsDirective, NgxEchartsModule };\n\n//# sourceMappingURL=ngx-echarts.js.map"],"sourceRoot":"webpack:///"}